/* Epsilon.java */
/* Generated By:JavaCC: Do not edit this line. Epsilon.java */
public class Epsilon implements EpsilonConstants {

    String A="\u005cn------------Errores:\u005cn";//Variable para almacenar los errores   
    String[] TE = {"\u005cnError L\u00e9xico. ", "\u005cnError Sint\u00e1ctico. ", "\u005cnError Sem\u00e1ntico. "};//Tipos de errores

    //Inicio de Variables para Semántica**************************************************************
    int ValorN;
    Cache Objeto_Variable = new Cache();//Variable Fluctuante
    String Type="", Valor=""; //Variables Cache para capturar el PAR
    String lugar = "";//Posición Variable donde se puede originar una inconsistencia
    java.util.ArrayList<ParOrd> ParOrdenado = new java.util.ArrayList<ParOrd>(); //Lista de IDs
    //Fin de Variables para Semántica**************************************************************
    //Inicio de Variables para Código Intermedio**************************************************************
    String ruta = "C:/Epsilon/CodigoIntermedio.txt";
    String ruta2 ="C:/Epsilon/CodInterm.txt";
    CTDOA codigo_aritmetico = new CTDOA();
    EscrituraCI CIsinOptim = new EscrituraCI(ruta2);
    EscrituraCI ECI = new EscrituraCI(ruta);//Escritura de Código Intermedio
    String CI = ""; //Almacén de Código Intermedio
    String CISoptm= "";
    String IGCI = ""; //IDENTIFICADOR en uso para la GENERACIÓN de CÓDIGO INTERMEDIO
    int label = 0;//Etiquetas usadas en mientras
    int label2=label;
    boolean aplicaGCI = true;//Valida que la instrucción este correcta para generar el Código Intermedio
    boolean vigilanteId = true;
    //Fin de Variables para Código Intermedio**************************************************************-------

    //Inicio de Variables para Optimización**************************************************************---------
    boolean T = false; //Debo cambiarlo. Se usa en Ingreso ID's
    java.util.ArrayList<ParOrd> IDsinUso = new java.util.ArrayList<ParOrd>();//lista con las variables muertas
    //Fin de Variables para Optimización**************************************************************-------

    //Inicio varibales para Ensamblador**************************************************************-------------
   String Call = "cmd /k start C:/Epsilon/Ensamble.bat";
    W_CPlusPlus trans = new W_CPlusPlus("C:/Epsilon/Implementacion.cpp");
    //Fin varibales para Ensamblador**************************************************************-------

    public static void main(String[] args) throws ParseException{

        Epsilon compilador = new Epsilon(System.in);
        compilador.Principal();
    }

  final public void Principal() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case INICIO:{
      jj_consume_token(INICIO);
trans.Write_to_CPlus("setlocale(LC_CTYPE,\u005c"spanish\u005c");\u005cn");
        trans.Write_to_CPlus("int numeroEntero;\u005cn");
        trans.Write_to_CPlus("string input; \u005cn"); // /\"Hola\";\n");
        trans.Write_to_CPlus("string s= \u005c"f\u005c";\u005cn");
        trans.Write_to_CPlus("int n;\u005cn");
     //   trans.Write_to_CPlus("system(\"Chcp 65001\");\n");

      break;
      }
    case TER:{
      jj_consume_token(TER);
A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba la palabra \u005c"Inicio\u005c"";
      break;
      }
    default:
      jj_la1[0] = jj_gen;
A+= TE[1] + posicion_token() + "No se ingres\u00f3 la palabra reservada \u005c"Inicio\u005c". Necesita ser ingresada";
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ROMPER:
      case LEER:
      case IMPRIMIR:
      case WHILE:
      case FOR:
      case IDENTIFICADOR:
      case NUMERO:
      case STRING:
      case BOOLEAN:
      case IF:
      case SWITCH:
      case TER:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ROMPER:{
        jj_consume_token(ROMPER);
trans.Write_to_CPlus("break;\u005cn");
        ARD0();
        break;
        }
      case NUMERO:{
        jj_consume_token(NUMERO);
Type = "Num";
        trans.Write_to_CPlus("float ");
        ARD1();
        break;
        }
      case STRING:{
        jj_consume_token(STRING);
trans.Write_to_CPlus("string ");
        Type = "Cad";
        ARD2();
        break;
        }
      case BOOLEAN:{
        jj_consume_token(BOOLEAN);
trans.Write_to_CPlus("bool ");
        Type = "Bool";
        ARD3();
        break;
        }
      case IDENTIFICADOR:{
        jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" "); */
        trans.Write_to_CPlus(token.image);
        Valor = token.image+"";
        IGCI = token.image;
                lugar = posicion_token();
                ExistenciaIDsConRedir();
        break;
        }
      case IF:{
        jj_consume_token(IF);
trans.Write_to_CPlus("if (");
        ARD4();
        trans.Write_to_CPlus("}\u005cn");
        break;
        }
      case WHILE:{
        jj_consume_token(WHILE);
trans.Write_to_CPlus("while (true) {\u005cn");
        ARD5();
        trans.Write_to_CPlus("}\u005cn");
        break;
        }
      case FOR:{
        jj_consume_token(FOR);
trans.Write_to_CPlus("for(");
        ARD6();
        trans.Write_to_CPlus("}\u005cn");
        break;
        }
      case LEER:{
        jj_consume_token(LEER);
// trans.Write_to_CPlus("cin >> ");
        ETA();
        break;
        }
      case TER:{
        jj_consume_token(TER);
ARD7();
        break;
        }
      case SWITCH:{
        jj_consume_token(SWITCH);
Segun();
        break;
        }
      case IMPRIMIR:{
        jj_consume_token(IMPRIMIR);
trans.Write_to_CPlus("cout << ");
        IPA();
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case FIN:{
      jj_consume_token(FIN);
trans.end_to_CPlus();
      break;
      }
    default:
      jj_la1[3] = jj_gen;
A+= TE[1] + posicion_token() + "No se ingres\u00f3 la palabra reservada \u005c"Fin\u005c". Necesita ser ingresada";
    }
if(!A.equals("\u005cn------------Errores:\u005cn"))   System.out.println(A);

            System.out.println("\u005cnCompilaci\u00f3n Finalizada.");

            if(A.equals("\u005cn------------Errores:\u005cn")){
                try{
                    System.out.println("Procesando ejecuci\u00f3n");
                    Runtime.getRuntime().exec(Call);
                } catch (java.io.IOException ex) {
                   System.out.println("Gracias");
                    //Logger.getLogger(Ejecucion.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
  }

/*JAVACODE
public String ql(String quitar){
    if (quitar == null || quitar.length == 0){
        return quitar;
    }
        return quitar.subString(1);
}*/

//----------------------INICIO DE MÉTODOS SOLO PARA ARRANCAR*******************************
  final public void ARD0() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);
ECI.EscribirB("Romper goto Lable"+(label+1) + "\u005cn");
        CIsinOptim.EscribirB("Romper goto Lable"+(label2+1) + "\u005cn");
      break;
      }
    default:
      jj_la1[4] = jj_gen;
A+= TE[1] + posicion_token() + "No se ingres\u00f3 un punto y coma. Se esparaba uno.";
    }
  }

  final public void ARD1() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        Valor = token.image;
        IGCI = token.image;
        trans.Write_to_CPlus(Valor+" ");
        lugar = posicion_token();
        validacionIDs();
        Asignar();
      break;
      }
    case TER:{
      jj_consume_token(TER);
vigilanteId = false;
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un Identificador.";
        Asignar();
      break;
      }
    default:
      jj_la1[5] = jj_gen;
vigilanteId = false;
        A+= TE[0] + posicion_token() + "No se ingres\u00f3 un identificador. Se esparaba un identificador.";
        Asignar();
    }
  }

  final public void ARD2() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image + " ");
        Valor = token.image + "";
        IGCI = token.image;
        lugar = posicion_token();
        validacionIDs();
        AsignacionS();
      break;
      }
    case TER:{
      jj_consume_token(TER);
vigilanteId = false;
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un Identificador.";
        Asignar();
      break;
      }
    default:
      jj_la1[6] = jj_gen;
vigilanteId = false;
        A+= TE[0] + posicion_token() + "No se ingres\u00f3 un identificador. Se esparaba un identificador.";
        Asignar();
    }
  }

  final public void ARD3() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image + " ");
        IGCI = token.image;
        Valor = token.image + "";
        lugar = posicion_token();
        validacionIDs();
        Objeto_Variable.setValor(token.image);
        AsignacionI();
      break;
      }
    case TER:{
      jj_consume_token(TER);
vigilanteId = false;
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un Identificador.";
        Asignar();
      break;
      }
    default:
      jj_la1[7] = jj_gen;
vigilanteId = false;
        A+= TE[0] + posicion_token() + "No se ingres\u00f3 un identificador. Se esparaba un identificador.";
        Asignar();
    }
  }

  final public void ARD4() throws ParseException {
    Pval();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
      break;
      }
    default:
      jj_la1[8] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEER:
      case IMPRIMIR:
      case WHILE:
      case FOR:
      case IDENTIFICADOR:
      case IF:
      case TER:{
        ;
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        Id_Para_Estrucuras();
        break;
        }
      case WHILE:{
        mientras();
        break;
        }
      case IF:{
        Condiciones();
        break;
        }
      case FOR:{
        para();
        break;
        }
      case LEER:
      case IMPRIMIR:
      case TER:{
        Funciones();
        break;
        }
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    try {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IF:{
        Condiciones();
        break;
        }
      case LD:{
        jj_consume_token(LD);
        break;
        }
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
    }
  }

  final public void ARD5() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
ECI.EscribirB("Label"+ (++label) + "\u005cnmientras {\u005cn\u005cn");
        CIsinOptim.EscribirB("Label"+ (++label2) + "\u005cnmientras {\u005cn\u005cn");
      break;
      }
    default:
      jj_la1[12] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LEER:
      case IMPRIMIR:
      case WHILE:
      case FOR:
      case IDENTIFICADOR:
      case IF:
      case TER:{
        ;
        break;
        }
      default:
        jj_la1[13] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        Id_Para_Estrucuras();
        break;
        }
      case IF:{
        Condiciones();
        break;
        }
      case WHILE:{
        mientras();
        break;
        }
      case FOR:{
        para();
        break;
        }
      case LEER:
      case IMPRIMIR:
      case TER:{
        Funciones();
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    try {
      jj_consume_token(LD);
ECI.EscribirB("} goto Label"+label+"\u005cnLabel"+(++label));
        CIsinOptim.EscribirB("} goto Label"+label2+"\u005cnLabel"+(++label2));
    } catch (ParseException e) {
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
    }
  }

  final public void ARD6() throws ParseException {
    PValR();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
      break;
      }
    default:
      jj_la1[15] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    try {
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEER:
        case IMPRIMIR:
        case WHILE:
        case FOR:
        case IDENTIFICADOR:
        case IF:
        case TER:{
          ;
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          break label_4;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFICADOR:{
          Id_Para_Estrucuras();
          break;
          }
        case IF:{
          Condiciones();
          break;
          }
        case WHILE:{
          mientras();
          break;
          }
        case FOR:{
          para();
          break;
          }
        case LEER:
        case IMPRIMIR:
        case TER:{
          Funciones();
          break;
          }
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(LD);
    } catch (ParseException e) {
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
    }
  }

  final public void ARD7() throws ParseException {
A += TE[0] + posicion_token() + "Se ingres\u00f3 " + token.image + ". No es reconocido";
  }

//----------------------FINAL DE MÉTODOS SOLO PARA ARRANCAR*******************************-


//----------------------INICIO DE MÉTODOS PARA DECLARACIONES Y OPERACIONES-------------------
  final public 
void Id_Para_Estrucuras() throws ParseException {
    jj_consume_token(IDENTIFICADOR);
//verifica el tipo
        vigilanteId = true;
        String temToken = token.image;
        String temTypeId = "";

        for (ParOrd e : ParOrdenado) {
            if (e.id.equals(temToken)) {
                temTypeId = e.tipo;
                e.id_uso();
                break;
            }
        }
        if (!temTypeId.equals("")){
            switch(temTypeId){
                case "Num":
                    //System.out.println("Num");
                    /*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
                    Valor = token.image;
                    IGCI = token.image;
                    trans.Write_to_CPlus(token.image);
                    lugar = posicion_token();
                    Asignar();
                    break;
                case "Cad":

                    /*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
                    Valor = token.image + "";
                    IGCI = token.image;
                    trans.Write_to_CPlus(token.image);
                    lugar = posicion_token();
                    AsignacionS();
                    break;
                case "Bool":
                    /*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
                    IGCI = token.image;
                    Valor = token.image + "";
                    trans.Write_to_CPlus(token.image);
                    lugar = posicion_token();
                    Objeto_Variable.setValor(token.image);
                    AsignacionI();
                    break;
            }
        }else {
            vigilanteId = false;
            AsignacionesVND();
        }
  }

//INICIO BLOQUE PARA GRAMÁTICA DE DECLARACIÓN DE VARIABLES NUMÉRICAS*******************************------
  final public void Asignar() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNACION:{
      jj_consume_token(ASIGNACION);
trans.Write_to_CPlus("= ");
        codigo_aritmetico = new CTDOA();
        IOV();
      break;
      }
    case PC:{
      jj_consume_token(PC);
trans.Write_to_CPlus(";\u005cn");
      break;
      }
    case TER:{
      jj_consume_token(TER);
vigilanteId = false;
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba el s\u00edmbolo de \u005c"Asignaci\u00f3n/Punto y Coma\u005c".";
      break;
      }
    default:
      jj_la1[18] = jj_gen;
vigilanteId = false;
        if(token.kind == IDENTIFICADOR){
            try{
            jj_consume_token(V_NUM);
            A+= TE[1] + posicion_token() + "No se ingres\u00f3 el s\u00edmbolo de \u005c"Asignaci\u00f3n\u005c".";
            Operadores();
            }catch(ParseException e){
                A+= TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 el \u005c"Punto y Coma\u005c".";
            }
        }
    }
  }

  final public void IOV() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image+" ");
        Objeto_Variable.setValor(token.image);
        codigo_aritmetico.add(token.image+"");
        Operadores();
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image+" ");
        Objeto_Variable.setValor(token.image);
        codigo_aritmetico.add(token.image);
        Operadores();
      break;
      }
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
vigilanteId = false;
        lugar = "(Lin." + token.beginLine + " Col."+ token.beginColumn +")";
        incompatibilidad_Operando(token.image,"N\u00famero (Num).");
        Operadores();
      break;
      }
    case VF:{
      jj_consume_token(VF);
vigilanteId = false;
        lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"N\u00famero (Num).");
        Operadores();
      break;
      }
    case TER:{
      jj_consume_token(TER);
//Token Error-No Pertenecen a la gramática
        vigilanteId = false;
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un n\u00famero";
        Operadores();
      break;
      }
    default:
      jj_la1[19] = jj_gen;
vigilanteId = false;
        A+= TE[1] + posicion_token() + "No se ingres\u00f3 un operando. Ingrese un n\u00famero";
        Operadores();
    }
  }

  final public void Operadores() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);
trans.Write_to_CPlus(";\u005cn");
        if(vigilanteId){
            System.out.println(codigo_aritmetico.longitud());
            if(codigo_aritmetico.longitud()>=3){
                CI += codigo_aritmetico.generarCodigo();
                CI += "    " + "    " + codigo_aritmetico.nombreVariable + "    " + Valor + "\u005cn\u005cn";
                CISoptm +=codigo_aritmetico.generarCodigosinoptimizar();
                CISoptm+="    " + "    " + codigo_aritmetico.nombreVariable + "    " + Valor + "\u005cn\u005cn";
                CIsinOptim.EscribirOA(CISoptm);
                ECI.EscribirOA(CI);
                codigo_aritmetico = new CTDOA();
                CISoptm ="";
                CI = "";
            }else{
                ECI.EscribirOA( "        " + Objeto_Variable.getString() + "    "+ Valor + "\u005cn\u005cn");//Al ser correcta la declaración se genera el código intermedio
                CIsinOptim.EscribirOA( "        " + Objeto_Variable.getString() + "    "+ Valor + "\u005cn\u005cn");//Al ser correcta la declaración se genera el código intermedio
            }
        }else vigilanteId = true;

        codigo_aritmetico = new CTDOA();
      break;
      }
    case MAS:{
      jj_consume_token(MAS);
trans.Write_to_CPlus("+ ");
        codigo_aritmetico.add(token.image);
        IOV();
      break;
      }
    case MENOS:{
      jj_consume_token(MENOS);
trans.Write_to_CPlus("- ");
        codigo_aritmetico.add(token.image);
        IOV();
      break;
      }
    case MULT:{
      jj_consume_token(MULT);
trans.Write_to_CPlus("* ");
        codigo_aritmetico.add(token.image);
        IOV();
      break;
      }
    case DIV:{
      jj_consume_token(DIV);
trans.Write_to_CPlus("/ ");
        codigo_aritmetico.add(token.image);
        IOV();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
trans.Write_to_CPlus("% ");
        codigo_aritmetico.add(token.image);
        IOV();
      break;
      }
    case UNION:{
      jj_consume_token(UNION);
vigilanteId = false;
        A+= TE[2]+ posicion_token() + "Se ingres\u00f3 el operador de uni\u00f3n '~'. Se esparaba un operador arit\u00e9mtico (+ , - , * , / , %)";
        IOV();
      break;
      }
    case TER:{
      jj_consume_token(TER);
//token error-no pertenecen a la gramatica
        vigilanteId = false;
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un operador aritm\u00e9tico (+ , - , * , / , %)";
        IOV();
      break;
      }
    default:
      jj_la1[20] = jj_gen;
vigilanteId = false;
        try{
            jj_consume_token(V_NUM);
            A+= TE[1] + posicion_token() + "No se ingres\u00f3 un operador aritm\u00e9tico. Podr\u00eda utilizar algo como: + , - , * , / , %";
            Operadores();
        } catch(ParseException e){
            A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un punto y coma. Se debe a\u00f1adir";
        }
    }
  }

///FIN BLOQUE PARA GRAMATICA DE DECLARACION DE VARIABLES NUMERICAS*******************************--------

///INICIO BLOQUE PARA GRAMATICA DE DECLARACION DE VARIABLES STRING*******************************--------
  final public void AsignacionS() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNACION:{
      jj_consume_token(ASIGNACION);
trans.Write_to_CPlus("= ");
        DCE();
      break;
      }
    case PC:{
      jj_consume_token(PC);
//Escribir bien
        trans.Write_to_CPlus(";\u005cn");
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un signo de asignaci\u00f3n(=) \u00f3 punto y coma (;)";
      break;
      }
    default:
      jj_la1[21] = jj_gen;
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un punto y coma. Se debe a\u00f1adir";
    }
  }

  final public void DCE() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image + " ");
        OperacionesS();
      break;
      }
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
trans.Write_to_CPlus("\u005c"" + subString(token.image) + "\u005c"");
        OperacionesS();
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Cadena (Cad)");
        OperacionesS();
      break;
      }
    case VF:{
      jj_consume_token(VF);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Cadena (Cad)");
        OperacionesS();
      break;
      }
    case TER:{
      jj_consume_token(TER);
//token error-no pertenecen a la gramatica
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido ' " + token.image + " '. Se esparaba un valor Alfanum\u00e9rico";
        OperacionesS();
      break;
      }
    default:
      jj_la1[22] = jj_gen;
A+= TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un Valor v\u00e1lido. Se debe ingresar alguna cadena de letras y/o n\u00fameros";
        OperacionesS();
    }
  }

  final public void OperacionesS() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNION:{
      jj_consume_token(UNION);
trans.Write_to_CPlus(" + ");
        DCE();
      break;
      }
    case PC:{
      jj_consume_token(PC);
trans.Write_to_CPlus(";\u005cn");
      break;
      }
    case MAS:{
      jj_consume_token(MAS);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Uni\u00f3n (~)");
        DCE();
      break;
      }
    case MENOS:{
      jj_consume_token(MENOS);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Uni\u00f3n (~)");
        DCE();
      break;
      }
    case MULT:{
      jj_consume_token(MULT);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Uni\u00f3n (~)");
        DCE();
      break;
      }
    case DIV:{
      jj_consume_token(DIV);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Uni\u00f3n (~)");
        DCE();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
lugar = "(Lin." +token.beginLine+", Col."+token.beginColumn+")";
        incompatibilidad_Operando(token.image,"Uni\u00f3n (~)");
        DCE();
      break;
      }
    case TER:{
      jj_consume_token(TER);
//token error-no pertenecen a la gramatica
        A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba el operador uni\u00f3n \u00f3 punto y coma";
        DCE();
      break;
      }
    default:
      jj_la1[23] = jj_gen;
try{
            jj_consume_token(V_ALF_NUM);

            A+= TE[1] + posicion_token() + "No se ingres\u00f3 un operador v\u00e1lido. Se esparaba el operador uni\u00f3n \u00f3 punto y coma";
            OperacionesS();
        } catch(ParseException e){
            A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un punto y coma. Se debe a\u00f1adir";
        }
    }
  }

///FIN BLOQUE PARA GRAMATICA DE DECLARACION DE DE VARIABLES STRING*******************************--------

///INICIO BLOQUE PARA GRAMATICA DE DECLARACION DE DE VARIABLES BOOLEANAS*******************************--------
  final public 
void AsignacionI() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNACION:{
      jj_consume_token(ASIGNACION);
trans.Write_to_CPlus("= ");
       DCK();
      break;
      }
    case PC:{
      jj_consume_token(PC);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una asignaci\u00f3n. Se esperaba algo como: Bool " + Objeto_Variable.getString() + " = Verdadero;";
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba el signo de asignaci\u00f3n (=)";
      break;
      }
    default:
      jj_la1[24] = jj_gen;
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una asignaci\u00f3n. Se esperaba algo como: Bool " + token.image + " = Verdadero;";
    }
  }

  final public void DCK() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VF:{
      jj_consume_token(VF);
if(token.image.equals("Verdadero"))
        trans.Write_to_CPlus("true ");
        else trans.Write_to_CPlus("false");
        DCL();
      break;
      }
    case MAS:{
      jj_consume_token(MAS);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case MENOS:{
      jj_consume_token(MENOS);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case MULT:{
      jj_consume_token(MULT);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case DIV:{
      jj_consume_token(DIV);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "Se ingres\u00f3 un valor incompatible \u005c""+ token.image+"\u005c". Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un Verdadero \u00f3 Falso";
        DCL();
      break;
      }
    default:
      jj_la1[25] = jj_gen;
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 el valor Booleano. Se esparaba un Verdadero \u00f3 Falso";
        DCL();
    }
  }

  final public void DCL() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);
trans.Write_to_CPlus(";\u005cn");
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba un Punto y coma";
      break;
      }
    default:
      jj_la1[26] = jj_gen;
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un punto y coma. Se debe a\u00f1adir";
    }
  }

///FIN BLOQUE PARA GRAMATICA DE DECLARACION DE DE VARIABLES BOOLEANAS*******************************

///INICIO BLOQUE PARA GRAMATICA DE DECLARACION DE DE VARIABLES NO DECLARADAS*******************************
  final public void AsignacionesVND() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ASIGNACION:{
      jj_consume_token(ASIGNACION);
DCS();
      break;
      }
    case PC:{
      jj_consume_token(PC);
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una asignaci\u00f3n. Se esperaba algo como: " + Objeto_Variable.getString() + " = Verdadero;";
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+= TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + "'. Se esparaba el signo de asignaci\u00f3n (=)";
        DCS();
      break;
      }
    default:
      jj_la1[27] = jj_gen;
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 el s\u00edmbolo de asignaci\u00f3n. Se esparaba el signo de asignaci\u00f3n (=)";
        DCS();
    }
  }

  final public void DCS() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
CoperadorOPC();
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
Operadores();
      break;
      }
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
OperacionesS();
      break;
      }
    case VF:{
      jj_consume_token(VF);
      jj_consume_token(PC);
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+=TE[0] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + ". Se esperaba alg\u00fan valor (num\u00e9rico, alfanum\u00e9rico, booleano)";
      break;
      }
    default:
      jj_la1[28] = jj_gen;
A+=TE[2] + posicion_token_edit(0, token.image.length()) + "No se le ha asignado ning\u00fan valor a la variable \u005c'" + token.image + ". La podr\u00eda retirar";
    }
  }

  final public void CoperadorOPC() throws ParseException, ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);
      break;
      }
    case MAS:{
      jj_consume_token(MAS);
IOV();
      break;
      }
    case MENOS:{
      jj_consume_token(MENOS);
IOV();
      break;
      }
    case MULT:{
      jj_consume_token(MULT);
IOV();
      break;
      }
    case DIV:{
      jj_consume_token(DIV);
IOV();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
IOV();
      break;
      }
    case UNION:{
      jj_consume_token(UNION);
DCE();
      break;
      }
    case TER:{
      jj_consume_token(TER);
A+=TE[1] + posicion_token() + "Se ingres\u00f3 un s\u00edmbolo no reconocido '" + token.image + ". Se esperaba un operador aritm\u00e9tico (+, -, *, /, %, ~)";
      break;
      }
    default:
      jj_la1[29] = jj_gen;
A+=TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 ning\u00fan s\u00edmbolo aritm\u00e9tico. Se esperaba un operador aritm\u00e9tico (+, -, *, /, %, ~) o un punto y coma (;)";
    }
  }

///FIN BLOQUE PARA GRAMATICA DE DECLARACION DE DE VARIABLES NO DECLARADAS*******************************

//********************FIN DE METODOS PARA DECLARACIONES Y OPERACIONES***********************




//****************************INICIO DE GRAMATICAS PARA IF*************************
  final public void Condiciones() throws ParseException {
    jj_consume_token(IF);
trans.Write_to_CPlus("if ( ");
    Pval();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
      break;
      }
    default:
      jj_la1[30] = jj_gen;
A += TE[0] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ROMPER:
      case LEER:
      case IMPRIMIR:
      case WHILE:
      case FOR:
      case IDENTIFICADOR:
      case IF:
      case TER:{
        ;
        break;
        }
      default:
        jj_la1[31] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        Id_Para_Estrucuras();
        break;
        }
      case IF:{
        Condiciones();
        break;
        }
      case WHILE:{
        mientras();
        break;
        }
      case FOR:{
        para();
        break;
        }
      case LEER:
      case IMPRIMIR:
      case TER:{
        Funciones();
        break;
        }
      case ROMPER:{
        Romper();
        break;
        }
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    try {
      jj_consume_token(LD);
trans.Write_to_CPlus("}\u005cn");
    } catch (ParseException e) {
A += TE[0] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
    }
  }

  final public void Pval() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PI:{
      jj_consume_token(PI);
      break;
      }
    default:
      jj_la1[33] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Izquierdo. Se debe agregar \u005c" ( \u005c"";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VF:{
      jj_consume_token(VF);
if(token.image.equals("Verdadero"))
        trans.Write_to_CPlus("true ");
        else trans.Write_to_CPlus("false ");;
        CNZ();
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image + " ");
        OperadorC();
      break;
      }
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
trans.Write_to_CPlus(token.image + " ");
        OperdadorCS();
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image + " ");
        CNF();//se redirecciona validando el tipo de dato

      break;
      }
    default:
      jj_la1[34] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una variable. Se debe agregar una o un valor a comparar";
        OperadorC();
    }
  }

  final public void OperadorC() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MAYORQ:{
      jj_consume_token(MAYORQ);
trans.Write_to_CPlus("> ");
        Sval();
      break;
      }
    case MENORQ:{
      jj_consume_token(MENORQ);
trans.Write_to_CPlus("< ");
        Sval();
      break;
      }
    case IGUAL:{
      jj_consume_token(IGUAL);
trans.Write_to_CPlus("== ");
        Sval();
      break;
      }
    case DIFERENTE:{
      jj_consume_token(DIFERENTE);
trans.Write_to_CPlus("!= ");
        Sval();
      break;
      }
    default:
      jj_la1[35] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un comparador se debe agregar uno";
        Sval();
    }
  }

  final public void Sval() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image + " ");
        CNZ();
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image + " ");
        CNG("Num");//Se valida que sea Numero

      break;
      }
    case VF:{
      jj_consume_token(VF);
if(token.image.equals("Verdadero"))
        trans.Write_to_CPlus("true");
        else
        trans.Write_to_CPlus("false");
        CNZ();
      break;
      }
    default:
      jj_la1[36] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una variable. Se debe agregar una o un valor a comparar";
        CNZ();
    }
  }

  final public void OperdadorCS() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IGUAL:{
      jj_consume_token(IGUAL);
trans.Write_to_CPlus(" == ");
        CNE();
      break;
      }
    case DIFERENTE:{
      jj_consume_token(DIFERENTE);
trans.Write_to_CPlus(" != ");
        CNE();
      break;
      }
    case MAYORQ:{
      jj_consume_token(MAYORQ);
trans.Write_to_CPlus(" > ");
        CNE();
      break;
      }
    case MENORQ:{
      jj_consume_token(MENORQ);
trans.Write_to_CPlus(" < ");
        CNE();
      break;
      }
    default:
      jj_la1[37] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 comparador. Se esperraba un \u005c" == \u005c" o un \u005c" != \u005c"";
        CNE();
    }
  }

  final public void CNE() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
trans.Write_to_CPlus("\u005c"" + subString(token.image) + "\u005c" ");
        CNZ();
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image);
        CNG("Cad");//Se valida que sea Alfanumericos

      break;
      }
    default:
      jj_la1[38] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una variable. Se debe agregar una o un valor a comparar";
        CNZ();
    }
  }

  public void CNF() throws ParseException {Valor = token.image;
    String tipo_dato ="";

    for(ParOrd e: ParOrdenado){//se revisa el tipo de dato
        if(e.id.equals(Valor)){
            tipo_dato = e.tipo;
            break;
        }
    }
    switch(tipo_dato){//se redirecciona segun el tipo de dato
        case "Bool":
            OperadorC();
            break;
        case "Num":
            OperadorC();
            break;
        case "Cad":
            OperdadorCS();
            break;
    }
  }

  public void CNG(String s) throws ParseException {//METODO QUE VALIDA LA CONSISTENCIA DEL SEGUNDO VALOR PARA UN IDENTIFICADOR
    // 1 == NUMERO, 2 == STRING

    Valor = token.image;
    String tipo_dato ="";

    for(ParOrd e: ParOrdenado){//se revisa el tipo de dato actual
        if(e.id.equals(Valor)){
            tipo_dato = e.tipo;
            break;
        }
    }
    if(tipo_dato.equals(s)) CNZ();
  }

  final public void CNZ() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case OR:{
      jj_consume_token(OR);
trans.Write_to_CPlus("|| ");
        Pval();
      break;
      }
    case AND:{
      jj_consume_token(AND);
trans.Write_to_CPlus("&& ");
        Pval();
      break;
      }
    default:
      jj_la1[40] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PD:{
        jj_consume_token(PD);
        break;
        }
      default:
        jj_la1[39] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Derecho. Se debe agregar \u005c" ) \u005c"";
      }
trans.Write_to_CPlus(" ){\u005cn");
    }
  }

//------------------------------FIN DE METODOS PARA IF*******************************-


//----------------------------INICIO DE GRAMATICAS PARA SWITCH------------------------------
  final public void Segun() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PI:{
      jj_consume_token(PI);
      break;
      }
    default:
      jj_la1[41] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Izquierdo. Se debe agregar \u005c" ( \u005c"";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus("switch(" +token.image + "){ \u005cn");
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");
        trans.Write_to_CPlus("numeroEntero = static_cast<int>(" + ql +"); \n");
        trans.Write_to_CPlus("switch(numeroEntero){ \n");  */
        trans.Write_to_CPlus("numeroEntero = static_cast<int>(" + token.image +"); \u005cn");
        trans.Write_to_CPlus("switch(numeroEntero){ \u005cn");
      break;
      }
    default:
      jj_la1[42] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una  variable. Se debe agregar una variable o un numero entero";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PD:{
      jj_consume_token(PD);
      break;
      }
    default:
      jj_la1[43] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Derecho. Se debe agregar \u005c" ) \u005c"";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
      break;
      }
    default:
      jj_la1[44] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    caso();
  }

  final public void caso() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case ROMPER:
    case LEER:
    case IMPRIMIR:
    case WHILE:
    case FOR:
    case IDENTIFICADOR:
    case V_NUM:
    case CASE:
    case PC:
    case ASOCIATIVO:
    case TER:{
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case CASE:{
        jj_consume_token(CASE);
trans.Write_to_CPlus("case ");
        break;
        }
      default:
        jj_la1[45] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 la palabra caso. Se debe agregar";
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case V_NUM:{
        jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image + ": \u005cn");
        break;
        }
      default:
        jj_la1[46] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 el numero de caso. Se debe agregar un numero entero";
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ASOCIATIVO:{
        jj_consume_token(ASOCIATIVO);
        break;
        }
      default:
        jj_la1[47] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 \u005c":\u005c". Se debe agregar";
      }
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEER:
        case IMPRIMIR:
        case WHILE:
        case FOR:
        case IDENTIFICADOR:
        case TER:{
          ;
          break;
          }
        default:
          jj_la1[48] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFICADOR:{
          Id_Para_Estrucuras();
          break;
          }
        case WHILE:{
          mientras();
          break;
          }
        case FOR:{
          para();
          break;
          }
        case LEER:
        case IMPRIMIR:
        case TER:{
          Funciones();
          break;
          }
        default:
          jj_la1[49] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ROMPER:{
        jj_consume_token(ROMPER);
trans.Write_to_CPlus("break; \u005cn");
        break;
        }
      default:
        jj_la1[50] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 \u005c"romper\u005c". Se debe agregar";
      }
      jj_consume_token(PC);
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 punto y coma. Se debe agregar \u005c";\u005c"";
caso();
      break;
      }
    default:
      jj_la1[52] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case LD:{
        jj_consume_token(LD);
trans.Write_to_CPlus("}\u005cn");
        break;
        }
      default:
        jj_la1[51] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
      }
    }
  }

//----------------------------FIN DE GRAMATICAS PARA SWITCH------------------------------

//*******************************INICIO DE GRAMATICAS PARA CICLOS(BUCLE)*******************************
  final public void mientras() throws ParseException {
    jj_consume_token(WHILE);
trans.Write_to_CPlus("While (true){\u005cn");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
ECI.EscribirB("Label"+ (++label) + "\u005cnmientras {\u005cn\u005cn");
        CIsinOptim.EscribirB("Label"+ (++label2) + "\u005cnmientras {\u005cn\u005cn");
      break;
      }
    default:
      jj_la1[53] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case ROMPER:
      case LEER:
      case IMPRIMIR:
      case WHILE:
      case FOR:
      case IDENTIFICADOR:
      case IF:
      case TER:{
        ;
        break;
        }
      default:
        jj_la1[54] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case IDENTIFICADOR:{
        Id_Para_Estrucuras();
        break;
        }
      case IF:{
        Condiciones();
        break;
        }
      case WHILE:{
        mientras();
        break;
        }
      case FOR:{
        para();
        break;
        }
      case LEER:
      case IMPRIMIR:
      case TER:{
        Funciones();
        break;
        }
      case ROMPER:{
        Romper();
        break;
        }
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    try {
      jj_consume_token(LD);
trans.Write_to_CPlus("}\u005cn");
        ECI.EscribirB("} goto Label"+label+"\u005cnLabel"+(++label));
        CIsinOptim.EscribirB("} goto Label"+label2+"\u005cnLabel"+(++label));
    } catch (ParseException e) {
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
    }
  }

//*******************************FIN DE METODOS PARA CICLOS(BUCLE)*******************************



//*******************************INICIO DE GRAMATICAS FOR *******************************
  final public void para() throws ParseException {
    jj_consume_token(FOR);
trans.Write_to_CPlus("for(");
    PValR();
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LI:{
      jj_consume_token(LI);
      break;
      }
    default:
      jj_la1[56] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Izquierda. Se debe agregar \u005c" { \u005c"";
    }
    try {
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case LEER:
        case IMPRIMIR:
        case WHILE:
        case FOR:
        case IDENTIFICADOR:
        case IF:
        case TER:{
          ;
          break;
          }
        default:
          jj_la1[57] = jj_gen;
          break label_8;
        }
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case IDENTIFICADOR:{
          Id_Para_Estrucuras();
          break;
          }
        case IF:{
          Condiciones();
          break;
          }
        case WHILE:{
          mientras();
          break;
          }
        case FOR:{
          para();
          break;
          }
        case LEER:
        case IMPRIMIR:
        case TER:{
          Funciones();
          break;
          }
        default:
          jj_la1[58] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(LD);
trans.Write_to_CPlus("}\u005cn");
    } catch (ParseException e) {
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una llave Derecha. Se debe agregar \u005c" } \u005c"";
    }
  }

//INICIO DE LA CONDICION DE REPETIR
  final public void PValR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PI:{
      jj_consume_token(PI);
      break;
      }
    default:
      jj_la1[59] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Izquierdo. Se debe agregar \u005c" ( \u005c"";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case VF:{
      jj_consume_token(VF);
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image);
        RPC();
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql + " = " + ql + "; "+ ql);
        */
        trans.Write_to_CPlus(token.image + " = " + token.image + "; "+ token.image);
        Valor = token.image;
        String Type ="";

        for(ParOrd e: ParOrdenado){//se revisa el tipo de dato
            if(e.id.equals(Valor)){
                Type = e.tipo;
                break;
            }
        }
        switch(Type){//se redirecciona segun el tipo de dato
            case "Num":
                RPC();
                break;
            /*case "Cad":
                RPCS();
                break;*/
        }
      break;
      }
    default:
      jj_la1[60] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una variable o un numero entero. Se debe agregar uno";
        RPC();
    }
  }

  final public void RPC() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MAYORQ:{
      jj_consume_token(MAYORQ);
trans.Write_to_CPlus(" > ");
        SValR();
      break;
      }
    case MENORQ:{
      jj_consume_token(MENORQ);
trans.Write_to_CPlus(" < ");
        SValR();
      break;
      }
    case IGUAL:{
      jj_consume_token(IGUAL);
trans.Write_to_CPlus(" == ");
        SValR();
      break;
      }
    case DIFERENTE:{
      jj_consume_token(DIFERENTE);
trans.Write_to_CPlus(" != ");
        SValR();
      break;
      }
    default:
      jj_la1[61] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una comparador. Se debe agregar \u005c" > \u005c", \u005c" < \u005c", \u005c" == \u005c", o \u005c" != \u005c"";
        SValR();
    }
  }

  final public void SValR() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image);
        RPG();
      break;
      }
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
//VALIDAR
        /*String im = ql(token.image);
        trans.Write_to_CPlus(ql);  */
        Valor = token.image;
        trans.Write_to_CPlus(token.image);
       for (ParOrd e: ParOrdenado){
        if(e.id.equals(Valor)){
            Type = e.tipo;
            break;
        }
       }
       if (!Type.equals("Num"))
        A+= TE[2] + posicion_token() + "El ID ingresado \u005c"" + token.image + "\u005c" no corresponde a un tipo de dato correcto. Se esperaba un valor de tipo Num\u00e9rico (Num)";
       RPG();
      break;
      }
    default:
      jj_la1[62] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una variable o un numero entero. Se debe agregar uno";
        RPG();
    }
  }

//*****************FIN DE LA CONDICION DEL CICLO REPETIR***************
//INICIO DEL PROCESO ASOCIATIVO DEL CICLO REPETIR
  final public void RPG() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);
      break;
      }
    default:
      jj_la1[63] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 un punto y coma. Se debe agregar \u005c" ; \u005c"";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus("; " + ql);  */
        trans.Write_to_CPlus("; "+token.image);
        Valor = token.image;
        Type = "";
        for(ParOrd e: ParOrdenado){
            if(e.id.equals(Valor)){
                Type = e.tipo;
                break;
            }
        }
        if(!Type.equals("Num"))
        A+= TE[2] + posicion_token() + "El ID ingresado \u005c"" + token.image + "\u005c" no corresponde a un tipo de dato correcto. Se esperaba un valor de tipo Num\u00e9rico (Num)";
        RPI();
      break;
      }
    default:
      jj_la1[64] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una variable. Se debe agregar una";
        RPI();
    }
  }

  final public void RPI() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case MAS:{
      jj_consume_token(MAS);
trans.Write_to_CPlus(" = " + Valor + " + ");
        RPJ();
      break;
      }
    case MENOS:{
      jj_consume_token(MENOS);
//
        trans.Write_to_CPlus(" = " + Valor + " - ");
        RPJ();
      break;
      }
    case MULT:{
      jj_consume_token(MULT);
trans.Write_to_CPlus(" = " + Valor + " * ");
        RPJ();
      break;
      }
    case DIV:{
      jj_consume_token(DIV);
//no aplica, quitar
        trans.Write_to_CPlus(" = " + Valor + " / ");
        RPJ();
      break;
      }
    case RESIDUO:{
      jj_consume_token(RESIDUO);
//no aplica, quitar
        trans.Write_to_CPlus(" = " + Valor + " % ");
        RPJ();
      break;
      }
    default:
      jj_la1[65] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void RPJ() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*String im = ql(token.image);
        trans.Write_to_CPlus(ql +") {\n");  */
        trans.Write_to_CPlus(token.image + ") {\u005cn");
        Valor = token.image;
        trans.Write_to_CPlus(token.image);
        Type = "";
        for(ParOrd e: ParOrdenado){
            if(e.id.equals(Valor)){
                Type = e.tipo;
                break;
            }
        }
        if(!Type.equals("Num"))
        A+= TE[2] + posicion_token() + "El ID ingresado \u005c"" + token.image + "\u005c" no corresponde a un tipo de dato correcto. Se esperaba un valor de tipo Num\u00e9rico (Num)";
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PD:{
        jj_consume_token(PD);
        break;
        }
      default:
        jj_la1[66] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Derecho. Se debe agregar \u005c" ) \u005c"";
      }
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image + ") {\u005cn");
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PD:{
        jj_consume_token(PD);
        break;
        }
      default:
        jj_la1[67] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Derecho. Se debe agregar \u005c" ) \u005c"";
      }
      break;
      }
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//*******************************FIN DE METODOS PARA CICLOS(FOR)*******************************




//*******************************INICIO DE LECTURA Y ESCRITURA*******************************
  final public void Funciones() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEER:
    case TER:{
      leer_Teclado();
      break;
      }
    case IMPRIMIR:{
      Impresion_Pantalla();
      break;
      }
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//*******************************INICIO DE GRAMATICA ENTRADA_TECLADO*******************************
  final public void leer_Teclado() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case LEER:{
      jj_consume_token(LEER);
//trans.Write_to_CPlus("cin >> ");
        ETA();
      break;
      }
    case TER:{
      jj_consume_token(TER);
A += TE[0] + posicion_token() + "Se ingres\u00f3 " + token.image + ". Se esperaba la palabra \u005c" leer \u005c"";
      break;
      }
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ETA() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PI:{
      jj_consume_token(PI);
ETB();
      break;
      }
    default:
      jj_la1[71] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "No se ingres\u00f3 una parentesis Izquierdo Se debe agregar \u005c" ( \u005c"";
        ETB();
    }
  }

  final public void ETB() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
//VALIDAR QUE EXISTE EL ID
        /*String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus("numeroEntero = s.compare(typeid(" + token.image +").name()); \u005cn");
        trans.Write_to_CPlus("if (numeroEntero == 0) {");
        trans.Write_to_CPlus("cin >> input;\u005cn");
        trans.Write_to_CPlus("try {\u005cn");
        trans.Write_to_CPlus(token.image + " = stoi(input); \u005cn }");
        trans.Write_to_CPlus("catch (const invalid_argument& e){\u005cn");
        trans.Write_to_CPlus("cout << \u005c"Error fatal: No ingresaste un numero. \u005c\u005cn\u005c"; \u005cn");
        trans.Write_to_CPlus("return 0; }\u005cn } \u005cn");
        trans.Write_to_CPlus("else{\u005cn");
        trans.Write_to_CPlus("cin >> " +token.image + ";\u005cn }");
       // trans.Write_to_CPlus();
      //  trans.Write_to_CPlus();
      //  trans.Write_to_CPlus();



      //  trans.Write_to_CPlus(token.image);
        ETC();
      break;
      }
    default:
      jj_la1[72] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "Se esperaba algun ID. Se de ingresar ID";
        ETC();
    }
  }

  final public void ETC() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PD:{
      jj_consume_token(PD);
      break;
      }
    default:
      jj_la1[73] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Derecho. Se debe agregar \u005c" ) \u005c"";
    }
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);

      break;
      }
    default:
      jj_la1[74] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "Se esperaba algun punto y coma. Se debe ingresar \u005c" ; \u005c"";
    }
  }

//*******************************FIN DE METODO ENTRADA_TECLADO*******************************
//*******************************INICIO DE GRAMATICA IMPRESION_PANTALLA*******************************-
  final public void Impresion_Pantalla() throws ParseException {
    jj_consume_token(IMPRIMIR);
trans.Write_to_CPlus("cout << ");
        IPA();
  }

  final public void IPA() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PI:{
      jj_consume_token(PI);
IPB();
      break;
      }
    default:
      jj_la1[75] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "No se ingres\u00f3 una parentesis Izquierdo Se debe agregar \u005c" ( \u005c"";
        IPB();
    }
  }

  final public void IPB() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case IDENTIFICADOR:{
      jj_consume_token(IDENTIFICADOR);
/*   String im = ql(token.image);
        trans.Write_to_CPlus(ql +" ");  */
        trans.Write_to_CPlus(token.image+" ");
        IPC();
      break;
      }
    case V_ALF_NUM:{
      jj_consume_token(V_ALF_NUM);
System.setProperty("file.encoding", "UTF-8");
        String pruebe = subString(token.image);
        char  pchar=163;
       pruebe = pruebe.replaceAll("\u00fa","hola si funciona1");
        // pruebe = pruebe.replaceAll("Ãº","hola si funciona2");
          pruebe = pruebe.replaceAll("\u00fa","\u00fa");//é
          pruebe = pruebe.replaceAll("\u00e9","\u00e9");
          pruebe = pruebe.replaceAll("\u00e1","\u00e1");
          pruebe = pruebe.replaceAll("\u00ed","\u00ed");
          pruebe = pruebe.replaceAll("\u00f3","\u00f3");
          pruebe = pruebe.replaceAll("\u00f1","\u00f1");
      //  trans.Write_to_CPlus("\"" + subString(token.image) +"\" ");      
        trans.Write_to_CPlus("\u005c"" + pruebe +"\u005c" ");
        IPC();
      break;
      }
    case V_NUM:{
      jj_consume_token(V_NUM);
trans.Write_to_CPlus(token.image+" ");
        IPC();
      break;
      }
    case VF:{
      jj_consume_token(VF);
trans.Write_to_CPlus(token.image+" ");
        IPC();
      break;
      }
    case TER:{
      jj_consume_token(TER);
A += TE[0] + posicion_token() + "Se ingres\u00f3 " + token.image + ". Se esperaba alguno como : ID, Num, Cad, Bool";
        IPC();
      break;
      }
    default:
      jj_la1[76] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "Se esperaba algun valor. Un valor \u005c"id\u005c", numero, Cadena, Booleano";
        IPC();
    }
  }

  final public void IPC() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case UNION:{
      jj_consume_token(UNION);
trans.Write_to_CPlus("<< ");
        IPB();
      break;
      }
    default:
      jj_la1[79] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PD:{
        jj_consume_token(PD);
        break;
        }
      default:
        jj_la1[77] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length()) + "No se ingres\u00f3 una parentesis Derecho. Se debe agregar \u005c" ) \u005c"";
      }
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case PC:{
        jj_consume_token(PC);
trans.Write_to_CPlus("<< endl;\u005cn");
        break;
        }
      default:
        jj_la1[78] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "Se esperaba algun punto y coma. Se debe ingresar \u005c" ; \u005c"";
      }
    }
  }

//*******************************FIN DE LECTURA Y ESCRITURA*******************************

//*******************************INICIO DE GRAMATICA ROMPER*****************************
  final public void Romper() throws ParseException {
    jj_consume_token(ROMPER);
trans.Write_to_CPlus("break;\u005cn");
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case PC:{
      jj_consume_token(PC);
      break;
      }
    default:
      jj_la1[80] = jj_gen;
A += TE[1] + posicion_token_edit(0, token.image.length() + 1) + "No se ingres\u00f3 un punto y coma. Se debe ingresar \u005c" ; \u005c".";
    }
  }

  public String posicion_token() throws ParseException {// lugar de la incidencia
    return "(Lin." + token.beginLine + ", Col." + token.beginColumn + "). ";
  }

  public String posicion_token_edit(int i, int e) throws ParseException {// lugar de la incidencia
    return "(Lin." + (token.beginLine + i )+ ", Col." + (token.beginColumn + e) + "). ";
  }

  public void incompatibilidad_Operando(String V, String tipo) throws ParseException {//metodo de error para operando incorrecto
    A+="\u005cnError Sem\u00e1ntico. " + lugar + " El valor ' " + V + " ' no corresponde al tipo de dato. Se esperaba un " + tipo;
  }

  public void ingresoIDs() throws ParseException {//almacenamiento de identificadores y su tipo
    ParOrdenado.add(new ParOrd(Type, Valor));
    ECI.EscribirD(Type + "   " + Valor + "\u005cn\u005cn");//Al ser correcta la declaracion se genera el codigo intermedio
    CIsinOptim.EscribirD(Type + "   " + Valor + "\u005cn\u005cn");//Al ser correcta la declaracion se genera el codigo intermedio

  }

  public void validacionIDs() throws ParseException {//validacion de que no existe otra variable con el mismo nombre declarada
    boolean v = false;
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v  = true;
            break;
        }
    }
    if(v) A +="\u005cnError Sem\u00e1ntico. " + lugar + " El id ' " + Valor + " ' ya est\u00e1 en uso";
    else ingresoIDs();
  }

  public void ExistenciaIDs() throws ParseException {//validacion de que las variables hayan sido declaradas
    boolean v = false;              // false para variable no declarada, true para variable declarada
    String TipoDato = "";
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            TipoDato = e.tipo;
            v = true;
            break;
        }
    }
    if(v) switch(TipoDato){
            case "Num":
                OperadorC();
                break;
            case "Cad":
                //falta
                break;
            case "Bool":
                //CNY();
                break;
    } else OperadorC();
  }

  public void ExistenciaIDsConRedir() throws ParseException {//existencia de variables con redireccion al tipo de declaracion
    boolean v = false;
    String s = "";
    for(ParOrd e : ParOrdenado){
        if(e.id.equals(Valor)){
            v = true;
            s = e.tipo;
            e.id_uso();//se aumenta su contador razonando que la varibale se esta utilizando.
            break;
        }
    }
    if(!v) {
        vigilanteId = false;
        A +="\u005cnError Sem\u00e1ntico. " + lugar + " El id ' " + Valor + " ' no se ha declarado";
        T = true;
        AsignacionesVND();
    }
    else {// si existe la variable
        switch(s){
            case "Num":
                Asignar();
                break;
            case "Cad":
                AsignacionS();
                break;
            case "Bool":
                AsignacionI();
                break;
        }
    }
  }

  public void Declaracion() throws ParseException {ECI.EscribirD(Type + "   " + Valor + "        "  + "null\u005cn\u005cn");//Al ser correcta la declaracion se genera el codigo intermedio
    CIsinOptim.EscribirD(Type + "   " + Valor + "        "  + "null\u005cn\u005cn");//Al ser correcta la declaracion se genera el codigo intermedio

  }

  public String subString(String s) throws ParseException {String s1 = s.substring(1, (s.length()-1));
    /*for(int i= 0; i<s.length(); i++){
        if(i != 0 && i != (s.length-1))
        s1+=s.cha
    }*/
    return s1;
  }

  /** Generated Token Manager. */
  public EpsilonTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[81];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x10,0xadbe0,0xadbe0,0x40000,0x2000000,0x800,0x800,0x800,0x800000,0x20bc0,0x20bc0,0x1020000,0x800000,0x20bc0,0x20bc0,0x800000,0x20bc0,0x20bc0,0x12000000,0x12c00,0x2000000,0x12000000,0x12c00,0x2000000,0x12000000,0x12400,0x2000000,0x12000000,0x12c00,0x2000000,0x800000,0x20be0,0x20be0,0x200000,0x12c00,0x8000000,0x12800,0x8000000,0xc00,0x400000,0xc0000000,0x200000,0x2800,0x400000,0x800000,0x100000,0x2000,0x4000000,0xbc0,0xbc0,0x20,0x1000000,0x6102be0,0x800000,0x20be0,0x20be0,0x800000,0x20bc0,0x20bc0,0x200000,0x12800,0x8000000,0x2800,0x2000000,0x800,0x0,0x400000,0x400000,0x2800,0xc0,0x40,0x200000,0x800,0x400000,0x2000000,0x200000,0x12c00,0x400000,0x2000000,0x0,0x2000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x800,0x800,0x800,0x0,0x0,0x800,0x800,0x800,0x0,0x800,0x800,0x0,0x0,0x800,0x800,0x0,0x800,0x800,0x800,0x800,0xfd0,0x800,0x800,0xfd0,0x800,0xbd0,0x800,0x800,0x800,0xfd0,0x0,0x800,0x800,0x0,0x0,0xe,0x0,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800,0x800,0x0,0x0,0x800,0x0,0x800,0x800,0x0,0x800,0x800,0x0,0x0,0xe,0x0,0x0,0x0,0x3d0,0x0,0x0,0x0,0x800,0x800,0x0,0x0,0x0,0x0,0x0,0x800,0x0,0x0,0x400,0x0,};
   }

  /** Constructor with InputStream. */
  public Epsilon(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Epsilon(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new EpsilonTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 81; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 81; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Epsilon(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new EpsilonTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 81; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 81; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Epsilon(EpsilonTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 81; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(EpsilonTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 81; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[44];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 81; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 44; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
